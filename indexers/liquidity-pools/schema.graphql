# ======================================================================================================================
# *** Common entities ***
# ======================================================================================================================

enum SwapType {
  BUY
  SELL
}

# Unused???
enum PoolOperationType {
  BUY
  SELL
}

enum LiquidityActionType {
  ADD
  REMOVE
}

# Use one pattern i.e. ALLCAPS for enum variants (viz ADD REMOVE)
enum AssetType {
  Bond
  External
  StableSwap
  Token
  XYK
  Erc20
}

# Use one pattern i.e. ALLCAPS for enum variants (viz ADD REMOVE)
enum AccountType {
  User
  Omnipool
  Stablepool
  XYK
  LBP
}

type Account @entity {
  "Account pubkey"
  id: ID!

  accountType: AccountType!

  # Use one name and variant of case for all occurances of one thing i.e. Xykpool if you must
  # Stableswap as entity and type of token (same as in runtime as this will be used alongside it should follow naming)
  lbpPool: LbpPool
  xykPool: XykPool
  omnipool: Omnipool
  stablepool: Stablepool

  initiatedSwaps: [Swap!]! @derivedFrom(field: "swapper")
  filledSwaps: [Swap!]! @derivedFrom(field: "filler")

  transfersTo: [Transfer!] @derivedFrom(field: "to")
  transfersFrom: [Transfer!] @derivedFrom(field: "from")

  # initiatedActions
  initiatedChainActivities: [ChainActivityTrace!]
    @derivedFrom(field: "originator")

  # participatedActions
  participatedChainActivities: [AccountChainActivityTrace!]
    @derivedFrom(field: "account")

  dcaSchedules: [DcaSchedule!] @derivedFrom(field: "owner")
  otcOrders: [OtcOrder!] @derivedFrom(field: "owner")

  # TODO: add proxy and multisig tracking
}

type Asset @entity {
  "Asset ID"
  id: ID!
  assetType: AssetType!
  name: String
  symbol: String
  decimals: Int
  xcmRateLimit: BigInt
  isSufficient: Boolean!
  existentialDeposit: BigInt!
  # note: existentialDeposit is probably taken 1:1 from the runtime,
  # real existential deposit will be calculated realtime based on the current price
}

type Transfer @entity {
  "TxId"
  id: ID!
  traceIds: [String!] # Does this in any way relate to the traceIds in the ChainActivityTrace? Should we link it?
  paraChainBlockHeight: Int!
  # TODO: Add relayChainBlockHeight or block as entity link which would include the
  # paraChainBlockHeight, paraChainBlockHash, paraChainBlockTimestamp, relayChainBlockHeight, relayChainBlockHash, relayChainBlockTimestamp, etc.
  assetId: Int! @index # entity link or just the ID? In these cases we could do BOTH for easy filtering and also easy manipulation if neccessary.
  extrinsicHash: String @index # extrinsic hash is not unique indentificator, add link to extrinsic entity and provide full id?
  from: Account!
  to: Account!
  amount: BigInt!
  txFee: BigInt!
}

type HistoricalAssetVolume @entity {
  "AssetId-paraChainBlockHeight"
  id: ID!
  asset: Asset!
  volumeIn: BigInt!
  volumeOut: BigInt!
  totalVolumeIn: BigInt!
  totalVolumeOut: BigInt!
  relayChainBlockHeight: Int! # add link to block entity?
  paraChainBlockHeight: Int! @index
}

type ProcessorStatus @entity {
  "1"
  id: ID!
  assetsActualisedAtBlock: Int! # assetsLastUpdatedAtBlock
  poolsDestroyedCheckPointAtBlock: Int #poolsDestroyedUpdatedAtBlock
  initialIndexingStartedAtTime: DateTime! # initialIndexingStartedAt
  initialIndexingFinishedAtTime: DateTime # initialIndexingFinishedAt
}

type DispatchErrorValue {
  index: Int
  error: String
}
# <= Why is this not single entity? =>
type DispatchError {
  kind: String
  value: DispatchErrorValue
}

# ======================================================================================================================
# *** Chain Activity Tracing ***
# ======================================================================================================================

enum TraceEntityType {
  SWAP
  TRANSFER
  STABLEPOOL_LIQUIDITY_ACTION # STABLESWAP_LIQUIDITY_ACTION
  OTC_ORDER_ACTION
  DCA_SCHEDULE # What does this mean?
  DCA_SCHEDULE_EXECUTION_ACTION # ACTION?
  DCA_RANDOMNESS_GENERATION_FAILED_ERROR # This seems weird here?
} # Do we need all of these?
type Block
  @entity { # Add more realychain block info (block hash, timestamp, etc.)
  "0003396328-000002-70ca4"
  id: ID!
  extrinsics: [Extrinsic] @derivedFrom(field: "block")
  calls: [Call] @derivedFrom(field: "block")
  events: [Event] @derivedFrom(field: "block")
  chainActivityTraces: [ChainActivityTrace]
    @derivedFrom(field: "createdAtBlock")
  relayChainBlockHeight: Int!
  paraChainBlockHeight: Int! @index
  paraChainBlockHash: String! @index
  paraChainBlockTimestamp: DateTime! @index
}

type Extrinsic @entity {
  "0003396328-000002-70ca4"
  id: ID!
  hash: String!
  calls: [Call] @derivedFrom(field: "extrinsic")
  paraChainBlockHeight: Int! @index
  block: Block!
}

type Call @entity {
  "0003396328-000002-70ca4-000003"
  id: ID!
  traceId: String! # link to entity?
  name: String!
  success: Boolean
  originKind: String!
  originValueKind: String
  originValue: String
  entityTypes: [TraceEntityType]
  extrinsic: Extrinsic!
  parent: Call
  subcalls: [Call] @derivedFrom(field: "parent")
  events: [Event] @derivedFrom(field: "call")
  paraChainBlockHeight: Int! @index
  block: Block!
}

enum EventGroup {
  EXTRINSIC
  INITIALIZATION
  FINALIZATION
  BUY_BACK # -> BUYBACK
  DCA
}

type Event @entity {
  "0006508857-000017-d2fd9"
  id: ID!
  traceId: String! # link to entity?
  indexInBlock: Int! # what is this?
  name: String!
  group: EventGroup
  phase: String!
  entityTypes: [TraceEntityType]
  call: Call
  paraChainBlockHeight: Int! @index
  block: Block!
}

type ChainActivityTrace @entity {
  # "extrinsic_id where particular ChainActivityTrace has bee initialised"
  id: ID!

  #  op-id://batch:111/batch:22/dca:<schedule_id>=2
  #  op-id://batch:111/batch:22/otc:<order_id>=3
  operationIds: [String!]

  #  There is no id specific of specific entity. This trace id can be used for multiple DB entities.
  #  trace-id://context:<call>/<extrinsic_id>/<call_id>/<call_id>/<call_id>
  #  trace-id://context:<event>/<block_id>:<group_name>/<event_index>

  #  trace-id://context:call/0003396328-000002-70ca4/0003396328-000002-70ca4-000002/0003396328-000002-70ca4-000003/0003681428-fa806-000020
  #  trace-id://context:event/0003396328-70ca4:buyback/2

  traceIds: [String!]!

  #  list of participant addresses to particular ChainActivityTrace
  participants: [AccountChainActivityTrace!]!
    @derivedFrom(field: "chainActivityTrace")

  # account who signed initial call of the extrinsic
  originator: Account # ^ move up
  # Scope of all accounts involved into particular activity trace. Required for easier filtering on API side.
  associatedAccountsFlat: [String!]! # participantAccounts
  childTraces: [ChainActivityTraceRelation] @derivedFrom(field: "parentTrace")
  parentTraces: [ChainActivityTraceRelation] @derivedFrom(field: "childTrace")

  createdAtParaChainBlockHeight: Int! @index # createdAtBlockHeight
  createdAtBlock: Block!
}

type AccountChainActivityTrace @entity {
  # <Account.id>-<ChainActivityTrace.id>
  id: ID!
  account: Account!
  chainActivityTrace: ChainActivityTrace!
}

type ChainActivityTraceRelation @entity {
  # <child_trace_id>-<parent_trace_id>
  id: ID!
  childTrace: ChainActivityTrace!
  parentTrace: ChainActivityTrace!
  createdAtParaChainBlockHeight: Int!
}

# ======================================================================================================================
# *** Swapped - Unified Trade event ***
# ======================================================================================================================

enum SwapFillerType { # Use one pattern i.e. ALLCAPS for enum variants (viz ADD REMOVE)
  Omnipool
  Stableswap
  XYK
  LBP
  OTC
}
enum TradeOperationType { # Use one pattern i.e. ALLCAPS for enum variants (viz ADD REMOVE EXACT_IN)
  ExactIn
  ExactOut
  ExactLimitIn # I don't think we use this
  ExactLimitOut # I don't think we use this
  LiquidityAdd
  LiquidityRemove
}
#enum SwappedExecutionTypeKind {
#  Batch
#  DCA
#  Omnipool
#  Router
#  Xcm
#  XcmExchange
#}
#
#type OperationStackElementBatch {
#  index: Int!
#  kind: SwappedExecutionTypeKind!
#  incrementalId: Int!
#}
#type OperationStackElementDca {
#  index: Int!
#  kind: SwappedExecutionTypeKind!
#  scheduleId: Int!
#  incrementalId: Int!
#}
#
#type OperationStackElementOmnipool {
#  index: Int!
#  kind: SwappedExecutionTypeKind!
#  incrementalId: Int!
#}
#type OperationStackElementRouter {
#  index: Int!
#  kind: SwappedExecutionTypeKind!
#  incrementalId: Int!
#}
#type OperationStackElementXcm {
#  index: Int!
#  kind: SwappedExecutionTypeKind!
#  incrementalId: Int!
#  message: String!
#}
#type OperationStackElementXcmExchange {
#  index: Int!
#  kind: SwappedExecutionTypeKind!
#  incrementalId: Int!
#}
#
#union OperationStackElement =
#  | OperationStackElementBatch
#  | OperationStackElementDca
#  | OperationStackElementOmnipool
#  | OperationStackElementRouter
#  | OperationStackElementXcm
#  | OperationStackElementXcmExchange
#
#type OperationStack @entity {
#  # <SwappedExecutionTypeKind>:<operation.value>/<SwappedExecutionTypeKind>:<operation.value[0]>:<operation.value[1]>/...
#  id: ID!
#  stackElements: [OperationStackElement!]!
#}

type SwapFee @entity {
  "uuid"
  id: ID!
  swap: Swap!
  asset: Asset!
  amount: BigInt!
  recipient: Account!
}

# Just SwapInput ?
type SwapInputAssetBalance @entity {
  "uuid"
  id: ID!
  swap: Swap!
  asset: Asset!
  amount: BigInt!
}

# Just SwapOutput ? Do we need 2 entities?
type SwapOutputAssetBalance @entity {
  "uuid"
  id: ID!
  swap: Swap!
  asset: Asset!
  amount: BigInt!
}

type Swap @entity {
  # reorder params to be more logical
  "indexer event_id (e.g. <block_number>-<block_hash_partial>-<event_index> 0006516718-9965d-000107)"
  id: ID!
  operationId: String
  traceIds: [String!]
  "Swapped event index within Trade events sequence"
  swapIndex: Int! @index
  swapper: Account!
  filler: Account!
  fillerType: SwapFillerType!
  operationType: TradeOperationType!
  fees: [SwapFee!]! @derivedFrom(field: "swap")
  inputs: [SwapInputAssetBalance!]! @derivedFrom(field: "swap")
  outputs: [SwapOutputAssetBalance!]! @derivedFrom(field: "swap")
  eventIndex: Int!
  extrinsicHash: String!
  relayChainBlockHeight: Int!
  dcaScheduleExecutionAction: DcaScheduleExecutionAction
  otcOrderFulfilment: OtcOrderAction
  paraChainBlockHeight: Int! @index
  paraChainTimestamp: DateTime! @index
}

# ======================================================================================================================
# *** LBP Pool ***
# ======================================================================================================================

# Either sort the fields alphabetically or by relevance I saw before relevance order and now alphabetical
type LbpPool @entity {
  id: ID!
  account: Account!
  assetA: Asset!
  assetB: Asset!
  assetABalance: BigInt!
  assetBBalance: BigInt!
  createdAt: DateTime!
  createdAtParaBlock: Int!
  isDestroyed: Boolean
  destroyedAtParaBlock: Int
  startBlockNumber: Int
  endBlockNumber: Int
  fee: [Int]
  feeCollector: Account
  repayTarget: BigInt
  initialWeight: Int # if relevance move after start/end block
  finalWeight: Int # if relevance move after start/end block
  owner: Account # if relevance move up
  historicalBlockPrices: [LbpPoolHistoricalPrice!]! @derivedFrom(field: "pool")
  historicalVolume: [LbpPoolHistoricalVolume!]! @derivedFrom(field: "pool")
  historicalData: [LbpPoolHistoricalData!]! @derivedFrom(field: "pool")
}

type LbpPoolHistoricalPrice @entity {
  "PoolId-paraChainBlockHeight"
  id: ID!
  pool: LbpPool!
  assetA: Asset!
  assetB: Asset!
  assetABalance: BigInt!
  assetBBalance: BigInt!
  relayChainBlockHeight: Int!
  paraChainBlockHeight: Int! @index
}

type LbpPoolHistoricalVolume @entity {
  "PoolId-paraChainBlockHeight"
  id: ID!
  pool: LbpPool!
  assetA: Asset!
  assetB: Asset!
  averagePrice: Float!
  assetAVolumeIn: BigInt!
  assetAVolumeOut: BigInt!
  assetATotalVolumeIn: BigInt!
  assetATotalVolumeOut: BigInt!
  assetAFee: BigInt!
  assetBFee: BigInt!
  assetATotalFees: BigInt!
  assetBTotalFees: BigInt!
  assetBVolumeIn: BigInt!
  assetBVolumeOut: BigInt!
  assetBTotalVolumeIn: BigInt!
  assetBTotalVolumeOut: BigInt!
  relayChainBlockHeight: Int!
  paraChainBlockHeight: Int! @index
}

type LbpPoolHistoricalData @entity {
  "poolAddress-assetId-paraChainBlockHeight"
  id: ID!
  pool: LbpPool!
  assetA: Asset!
  assetB: Asset!
  assetABalance: BigInt!
  assetBBalance: BigInt!

  owner: Account!
  start: Int
  end: Int
  initialWeight: Int!
  finalWeight: Int!
  weightCurve: String!
  fee: [Int!]!
  feeCollector: Account
  repayTarget: BigInt!

  relayChainBlockHeight: Int!
  paraChainBlockHeight: Int! @index
}

# ======================================================================================================================
# *** XYK Pool ***
# ======================================================================================================================

type XykPool @entity {
  id: ID!
  account: Account!
  assetA: Asset!
  assetB: Asset!
  shareToken: Asset!
  assetABalance: BigInt!
  assetBBalance: BigInt!
  initialSharesAmount: BigInt!
  createdAt: DateTime!
  createdAtParaBlock: Int!
  isDestroyed: Boolean
  destroyedAtParaBlock: Int
  historicalBlockPrices: [XykPoolHistoricalPrice!]! @derivedFrom(field: "pool")
  historicalVolume: [XykPoolHistoricalVolume!]! @derivedFrom(field: "pool")
  historicalData: [XykPoolHistoricalData!]! @derivedFrom(field: "pool")
}

type XykPoolHistoricalPrice @entity {
  "PoolId-paraChainBlockHeight"
  id: ID!
  pool: XykPool!
  assetA: Asset!
  assetB: Asset!
  assetABalance: BigInt!
  assetBBalance: BigInt!
  relayChainBlockHeight: Int!
  paraChainBlockHeight: Int! @index
}

type XykPoolHistoricalVolume @entity {
  "PoolId-paraChainBlockHeight"
  id: ID!
  pool: XykPool!
  assetA: Asset!
  assetB: Asset!
  averagePrice: Float!
  assetAVolumeIn: BigInt!
  assetAVolumeOut: BigInt!
  assetATotalVolumeIn: BigInt!
  assetATotalVolumeOut: BigInt!
  assetAFee: BigInt!
  assetBFee: BigInt!
  assetATotalFees: BigInt!
  assetBTotalFees: BigInt!
  assetBVolumeIn: BigInt!
  assetBVolumeOut: BigInt!
  assetBTotalVolumeIn: BigInt!
  assetBTotalVolumeOut: BigInt!
  relayChainBlockHeight: Int!
  paraChainBlockHeight: Int! @index
}

type XykPoolHistoricalData @entity {
  "poolAddress-assetId-paraChainBlockHeight"
  id: ID!
  pool: XykPool!
  assetA: Asset!
  assetB: Asset!
  assetABalance: BigInt!
  assetBBalance: BigInt!
  relayChainBlockHeight: Int!
  paraChainBlockHeight: Int! @index # link to entity?
}

# ======================================================================================================================
# *** Omnipool ***
# ======================================================================================================================

type Omnipool @entity {
  id: ID!
  account: Account!
  createdAt: DateTime!
  createdAtParaBlock: Int!
  isDestroyed: Boolean
  destroyedAtParaBlock: Int
  assets: [OmnipoolAsset!]! @derivedFrom(field: "pool")
}

type OmnipoolAsset @entity {
  "OmnipoolId-AssetId"
  id: ID!
  asset: Asset!
  initialAmount: BigInt
  initialPrice: BigInt
  pool: Omnipool!
  createdAt: DateTime!
  createdAtParaBlock: Int!
  isRemoved: Boolean # NOTE: Possibly can be re-added
  removedAtParaBlock: Int
  removedAmount: BigInt # What does this mean? If it's tied to removal can we just link to [removedEvent] instead?
  hubWithdrawn: BigInt # What does this mean? If it's tied to removal can we just link to [removedEvent] instead?
  historicalVolume: [OmnipoolAssetHistoricalVolume!]!
    @derivedFrom(field: "omnipoolAsset")
  historicalData: [OmnipoolAssetHistoricalData!]!
    @derivedFrom(field: "omnipoolAsset")
}

type OmnipoolAssetHistoricalVolume @entity {
  "OmnipoolAssetId-paraChainBlockHeight"
  id: ID!
  omnipoolAsset: OmnipoolAsset!
  assetVolumeIn: BigInt!
  assetVolumeOut: BigInt!
  assetTotalVolumeIn: BigInt!
  assetTotalVolumeOut: BigInt!
  assetFee: BigInt!
  assetTotalFees: BigInt!
  relayChainBlockHeight: Int!
  paraChainBlockHeight: Int! @index
}

type OmnipoolAssetHistoricalData @entity {
  "OmnipoolAssetId-paraChainBlockHeight"
  id: ID!
  omnipoolAsset: OmnipoolAsset!
  asset: Asset!

  stateCap: BigInt! # What does this mean? AssetCap?
  stateShares: BigInt! # AssetShares?
  stateHubReserve: BigInt! # AssetHubReserve?
  stateProtocolShares: BigInt! # AssetProtocolShares?
  balanceFree: BigInt! # freeBalance?
  balanceFlags: BigInt! # AssetFlags? move up if yes
  balanceFrozen: BigInt! # not sure if any of these down are possible. Would check with Martin to be sure
  balanceReserved: BigInt!
  balanceFeeFrozen: BigInt!
  balanceMiscFrozen: BigInt!

  relayChainBlockHeight: Int!
  paraChainBlockHeight: Int! @index
}

# ======================================================================================================================
# *** Stablepool ***
# ======================================================================================================================

type Stablepool
  @entity { # Stableswap
  id: ID!
  account: Account!
  createdAt: DateTime!
  createdAtParaBlock: Int! # block entity link
  isDestroyed: Boolean
  destroyedAtParaBlock: Int
  assets: [StablepoolAsset!]! @derivedFrom(field: "pool")
}

type StablepoolAsset @entity {
  "stablepoolId-assetId"
  id: ID!
  pool: Stablepool!
  asset: Asset!
  amount: BigInt!
}

type StablepoolHistoricalVolume @entity {
  "stablepoolId-paraChainBlockHeight"
  id: ID!
  pool: Stablepool!
  assetVolumes: [StablepoolAssetHistoricalVolume!]!
    @derivedFrom(field: "volumesCollection")
  relayChainBlockHeight: Int!
  paraChainBlockHeight: Int! @index
}

type StablepoolAssetHistoricalVolume @entity {
  "stablepoolId-assetId-paraChainBlockHeight"
  id: ID!
  volumesCollection: StablepoolHistoricalVolume!
  asset: Asset!

  swapFee: BigInt!
  swapTotalFees: BigInt!
  liqFee: BigInt! # liquidityFee
  liqTotalFees: BigInt!
  routedLiqFee: BigInt! # what is this? Isn't this just liquidityFee?
  routedLiqTotalFees: BigInt!

  swapVolumeIn: BigInt!
  swapVolumeOut: BigInt!
  swapTotalVolumeIn: BigInt!
  swapTotalVolumeOut: BigInt!

  liqAddedAmount: BigInt!
  liqRemovedAmount: BigInt!
  liqAddedTotalAmount: BigInt!
  liqRemovedTotalAmount: BigInt!

  routedLiqAddedAmount: BigInt! # what is this? Why is it just in stableswap?
  routedLiqRemovedAmount: BigInt!
  routedLiqAddedTotalAmount: BigInt!
  routedLiqRemovedTotalAmount: BigInt!

  paraChainBlockHeight: Int! @index # link to block entity
}

type StablepoolLiquidityAction @entity {
  "poolId-paraChainBlockHeight-indexInBlock"
  id: ID!
  traceIds: [String!]
  pool: Stablepool!
  sharesAmount: BigInt!
  feeAmount: BigInt! # this is only used here we should have naming consistency also I believe this could be array?
  assetAmounts: [StablepoolAssetLiquidityAmount!]!
    @derivedFrom(field: "liquidityAction")
  actionType: LiquidityActionType!
  indexInBlock: Int! @index
  relayChainBlockHeight: Int!
  paraChainBlockHeight: Int! @index # link to block entity
}

# Maybe we should use the same pattern for all pools instead of using assetA and assetB?
# This would then be just some generic asset amount type not backlinked to stablepool (This should be automatic no?)
type StablepoolAssetLiquidityAmount @entity {
  "poolId-assetId-paraChainBlockHeight-indexInBlock"
  id: ID!
  liquidityAction: StablepoolLiquidityAction!
  asset: Asset!
  amount: BigInt!
}

type StablepoolHistoricalData @entity {
  "stablepoolId-paraChainBlockHeight"
  id: ID!
  pool: Stablepool!
  assetsData: [StablepoolAssetHistoricalData!]!
    @derivedFrom(field: "poolHistoricalData")
  initialAmplification: Int!
  finalAmplification: Int!
  initialBlock: Int! # initialAmplificationChangeAt
  finalBlock: Int! # finalAmplificationChangeAt
  fee: Int! # is this amount or percentage
  relayChainBlockHeight: Int!
  paraChainBlockHeight: Int! @index
}

type StablepoolAssetHistoricalData @entity {
  "stablepoolId-assetId-paraChainBlockHeight"
  id: ID!
  asset: Asset!
  poolHistoricalData: StablepoolHistoricalData!
  free: BigInt!
  reserved: BigInt!
  miscFrozen: BigInt
  feeFrozen: BigInt
  frozen: BigInt
  flags: BigInt # here it's flags, in omnipool it's balanceFlags consistency pls
  paraChainBlockHeight: Int! @index # link to block entity
}

# ======================================================================================================================
# *** DCA ***
# ======================================================================================================================

enum DcaScheduleOrderKind { # DcaScheduleOrderType (consistency)
  BUY
  SELL
}

enum DcaScheduleStatus {
  OPEN # STARTED
  COMPLETED
  TERMINATED
}
enum DcaScheduleExecutionStatus {
  PLANNED
  EXECUTED
  FAILED
}

type DcaSchedule @entity {
  "schedule_id as string"
  id: ID!
  operationId: String
  traceIds: [String!]
  startExecutionBlock: Int
  owner: Account! # move up
  period: Int
  totalAmount: BigInt
  slippage: Int
  maxRetries: Int
  stabilityThreshold: Int
  assetIn: Asset
  assetOut: Asset
  amountOut: BigInt
  amountIn: BigInt # sort
  maxAmountIn: BigInt
  minAmountOut: BigInt
  orderKind: DcaScheduleOrderKind! # orderType
  orderRoutes: [DcaScheduleOrderRoute] @derivedFrom(field: "schedule")

  totalExecutedAmountIn: BigInt
  totalExecutedAmountOut: BigInt

  status: DcaScheduleStatus @index
  statusUpdatedAtBlockHeight: Int # Link to block entity statusUpdatedAtBlock
  statusMemo: DispatchError
  createdAtRelayBlockHeight: Int!
  createdAtParaBlockHeight: Int! @index

  executions: [DcaScheduleExecution] @derivedFrom(field: "schedule")
}

# do we need different route entity for DcaSchedule?
type DcaScheduleOrderRoute @entity {
  "<dca_schedule_id>-<asset_in_id>-<asset_out_id>"
  id: ID!
  schedule: DcaSchedule!
  poolKind: SwapFillerType
  assetIn: Asset
  assetOut: Asset
}

type DcaScheduleExecution @entity {
  "<dca_schedule_id>-<block_height>"
  id: ID!
  schedule: DcaSchedule!
  status: DcaScheduleExecutionStatus @index
  amountOut: BigInt
  amountIn: BigInt
  actions: [DcaScheduleExecutionAction] @derivedFrom(field: "scheduleExecution")
}

# How can we have multiple exection actions for one execution? Can't we merge this to one entity?

type DcaScheduleExecutionAction @entity {
  "<dca_schedule_execution_id>-<dca_schedule_execution_status>"
  id: ID!
  operationIds: [String]
  traceIds: [String!]
  swaps: [Swap] @derivedFrom(field: "dcaScheduleExecutionAction")
  scheduleExecution: DcaScheduleExecution!
  status: DcaScheduleExecutionStatus @index
  statusMemo: DispatchError
  relayChainBlockHeight: Int!
  paraChainBlockHeight: Int! @index
}

type DcaRandomnessGenerationFailedError @entity {
  # this is just error state for DCA execution doesn't need to be separate entity we can store status as failed and add error
  "<paraChainBlockHeight>-<indexInBlock>"
  id: ID!
  operationId: String
  traceIds: [String!]
  indexInBlock: Int!
  relayChainBlockHeight: Int!
  paraChainBlockHeight: Int! @index
  error: DispatchError
}

# ======================================================================================================================
# *** OTC ***
# ======================================================================================================================

enum OtcOrderStatus {
  OPEN
  CANCELED
  FILLED
  PARTIALLY_FILLED
}

enum OtcOrderActionKind { # OtcOrderActionType
  CREATED
  CANCELED
  FILLED
  PARTIALLY_FILLED
}

type OtcOrder @entity {
  "order_id as string"
  id: ID!
  owner: Account!
  assetIn: Asset!
  assetOut: Asset!
  amountOut: BigInt!
  amountIn: BigInt!
  partiallyFillable: Boolean
  status: OtcOrderStatus @index
  createdAtRelayBlockHeight: Int!
  createdAtParaBlockHeight: Int! @index

  totalFilledAmountIn: BigInt
  totalFilledAmountOut: BigInt

  actions: [OtcOrderAction] @derivedFrom(field: "order")
}

type OtcOrderAction @entity {
  "<otc_order_id>-<event_id>"
  id: ID!
  operationId: String @index
  traceIds: [String!]
  kind: OtcOrderActionKind @index
  order: OtcOrder!
  amountIn: BigInt
  amountOut: BigInt
  fee: BigInt
  filler: Account
  eventIndex: Int!
  swap: Swap
  relayChainBlockHeight: Int!
  paraChainBlockHeight: Int! @index # link to block entity?
}
